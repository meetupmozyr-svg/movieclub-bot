# event_bot.py
import os
import json
from pathlib import Path
from typing import Dict

from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
)
from telegram.ext import (
    ApplicationBuilder,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
)

DATA_FILE = Path("events.json")


def load_data() -> Dict:
    if DATA_FILE.exists():
        return json.loads(DATA_FILE.read_text())
    return {"events": {}}


def save_data(data: Dict):
    DATA_FILE.write_text(json.dumps(data, indent=2, ensure_ascii=False))


def make_event_keyboard(event_id: str, event: Dict):
    joined = event["joined"]
    waitlist = event["waitlist"]
    capacity = event["capacity"]
    spots_filled = len(joined)
    kb = [
        [
            InlineKeyboardButton(f"✅ Join ({spots_filled}/{capacity})", callback_data=f"join|{event_id}"),
            InlineKeyboardButton("❌ Can't come", callback_data=f"leave|{event_id}")
        ],
    ]
    if spots_filled >= capacity:
        kb.append([InlineKeyboardButton(f"🕒 Waitlist ({len(waitlist)})", callback_data=f"wait|{event_id}")])
    return InlineKeyboardMarkup(kb)


def format_event_message(event: Dict):
    return (
        f"🎬 <b>{event['title']}</b>\n"
        f"📅 {event['date']}\n"
        f"📍 {event.get('location','(no location)')}\n\n"
        f"{event.get('description','(no description)')}\n\n"
        f"👥 <b>{len(event['joined'])}/{event['capacity']}</b> spots filled\n"
        f"🕒 Waitlist: {len(event['waitlist'])}"
    )


async def create_event_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Example usage: /create_event Title | 2025-11-02 20:00 | 10 | Cinema Hall | Short description...
    user = update.effective_user
    if not user:
        return
    if not context.args:
        await update.message.reply_text("Usage:\n/create_event Title | 2025-11-02 20:00 | capacity | location | description")
        return

    raw = " ".join(context.args)
    parts = [p.strip() for p in raw.split("|")]
    if len(parts) < 3:
        await update.message.reply_text("Please provide at least Title | Date | capacity")
        return

    title, date, capacity = parts[0], parts[1], int(parts[2])
    location = parts[3] if len(parts) > 3 else ""
    description = parts[4] if len(parts) > 4 else ""

    data = load_data()
    event_id = str(max([int(k) for k in data['events'].keys()] + [0]) + 1)
    event = {
        "id": event_id,
        "title": title,
        "date": date,
        "capacity": capacity,
        "location": location,
        "description": description,
        "creator_id": user.id,
        "message_id": None,
        "channel": os.environ.get("CHANNEL", "@kinovinomoz"),  # change default if needed
        "joined": [],
        "waitlist": []
    }
    data["events"][event_id] = event
    save_data(data)

    # Post to channel (bot must be admin!)
    app = context.application
    text = format_event_message(event)
    keyboard = make_event_keyboard(event_id, event)
    sent = await app.bot.send_message(chat_id=event["channel"], text=text, reply_markup=keyboard, parse_mode="HTML")

    event["message_id"] = sent.message_id
    data["events"][event_id] = event
    save_data(data)

    await update.message.reply_text(f"Event created and posted to {event['channel']} (event id {event_id}).")


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = load_data()
    action, event_id = query.data.split("|")
    event = data["events"].get(event_id)
    if not event:
        await query.edit_message_text("Event not found or expired.")
        return

    user_id = query.from_user.id

    # remove user from any list first
    if user_id in event["joined"]:
        event["joined"].remove(user_id)
    if user_id in event["waitlist"]:
        event["waitlist"].remove(user_id)

    if action == "join":
        if len(event["joined"]) < event["capacity"]:
            event["joined"].append(user_id)
            response = "You are registered ✅"
            else:
            event["waitlist"].append(user_id)
            response = "Event is full — you were added to the waitlist 🕒"
    elif action == "leave":
        response = "You are marked as not coming ❌"
    elif action == "wait":
        event["waitlist"].append(user_id)
        response = "You were added to the waitlist 🕒"
    else:
        response = "Unknown action."

    # promote if space opened
    while len(event["joined"]) < event["capacity"] and event["waitlist"]:
        promoted = event["waitlist"].pop(0)
        if promoted not in event["joined"]:
            event["joined"].append(promoted)
            try:
                await context.bot.send_message(chat_id=promoted, text=f"You were moved from waitlist to confirmed for {event['title']} on {event['date']} ✅")
            except Exception:
                pass

    data["events"][event_id] = event
    save_data(data)

    # edit channel message to reflect new counts
    try:
        await context.bot.edit_message_text(
            chat_id=event["channel"],
            message_id=event["message_id"],
            text=format_event_message(event),
            reply_markup=make_event_keyboard(event_id, event),
            parse_mode="HTML",
        )
    except Exception:
        pass

    # send user feedback
    try:
        await query.from_user.send_message(response)
    except Exception:
        await query.answer(text=response, show_alert=False)


async def my_events_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    data = load_data()
    out = []
    for e in data["events"].values():
        if user_id in e["joined"]:
            out.append(f"{e['title']} — Joined — {e['date']}")
        elif user_id in e["waitlist"]:
            out.append(f"{e['title']} — Waitlist — {e['date']}")
    if not out:
        await update.message.reply_text("You have no RSVPs.")
    else:
        await update.message.reply_text("\n".join(out))


def main():
    token = os.environ.get("BOT_TOKEN")
    app = ApplicationBuilder().token(token).build()

    app.add_handler(CommandHandler("create_event", create_event_command))
    app.add_handler(CommandHandler("my_events", my_events_command))
    app.add_handler(CallbackQueryHandler(button_handler))

    print("Bot started (polling). Press Ctrl-C to stop.")
    app.run_polling()


if __name__ == "__main__":
    main()
